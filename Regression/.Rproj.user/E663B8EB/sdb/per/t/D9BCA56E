{
    "collab_server" : "",
    "contents" : "---\ntitle: \"reg_class_marks\"\nauthor: \"Nick Marks\"\ndate: \"12/7/2017\"\noutput: html_notebook\n---\n\n```{r setup, include=FALSE}\nlibrary(pacman)\np_load(caret)\np_load(ggplot2)\np_load(plyr)    # need to load before dplyr due to presense of plyr still in gbm\np_load(dplyr)\np_load(Hmisc)\np_load(magrittr)\np_load(tidyr)\np_load(scales)\np_load(rms)\np_load(broom)\np_load(stargazer)\np_load(knitr)\np_load(emisc)\n\nknitr::opts_chunk$set(comment = NULL)\n\noptions(scipen = 9) # eliminate scientific notation\nmovie_folder_id = 13948823224\n\nold <- theme_get()\nthe_new <- old %+% theme(text = element_text(family = \"HelveticaNeue-Light\"),\n    panel.background = element_rect(fill = \"transparent\",colour = NA),\n  panel.grid.major = element_line(colour = \"grey\"))\ntheme_set(the_new)\n\nset.seed(20161123)  # get the same results when using stochastic functions\n```\n\n\n# 1. First make sure that you can run the code in this class.\n\n```{r load_data}\npacman::p_load(eboxr)\ntransactions <- eboxr_read(\"/Users/curtbergmann/Box Sync/Elicit Education/scholar/regclass/transactions.RDS\",\n           read_fun = readRDS)\ntransactions %<>%      # note the %<>% combination pipe plus re-assign operator\n                       # remember the idea of idempotence from the summary statistics course?\n  mutate(appliance_purchase_factor = factor(appliance_purchase, levels = c(0, 1), labels = c(\"No\", \"Yes\")), \n         appliance_purchase_binary = appliance_purchase)\n```\n\n# 2. Send your designated reviewer the boxplot from rerunning the top models using the bootstrap\n\n```{r rerunning_top_models, echo = FALSE, warning = FALSE}\n# Create bootstrap model function to run top models\nboot_train <- function(form){\n  train(formula(form), data=transactions %>% \n          select(-appliance_purchase_factor\n                 , -appliance_purchase_binary\n                 ,-customer_id)\n        , method='gbm'\n        , metric = \"ROC\"\n        , verbose = FALSE\n        , trControl=trainControl(method='boot'\n                                 , number = 25\n                                 , classProbs=TRUE\n                                 , summaryFunction=twoClassSummary\n                                 , savePredictions = TRUE))\n} \n\n# Set up parallel processing\np_load(doParallel)\ndoParallel::registerDoParallel(cores = detectCores())\n\ntop_models <- readRDS(\"top_models.rds\")\n\ntransactions %<>%\n  mutate(appliance_purchase = relevel(appliance_purchase_factor, ref = 'Yes')) # changing the order so\n\nbootstrap_results <- data_frame() %>% \n  add_model(boot_train(top_models$form[[1]])\n            , desc = paste('boot_train',top_models$desc[[1]])\n            , logistic_true = 1) %>% \n    add_model(boot_train(top_models$form[[2]])\n            , desc = paste('boot_train',top_models$desc[[2]])\n            , logistic_true = 1) %>% \n    add_model(boot_train(top_models$form[[3]])\n            , desc = paste('boot_train',top_models$desc[[3]])\n            , logistic_true = 1) %>% \n    add_model(boot_train(top_models$form[[4]])\n            , desc = paste('boot_train',top_models$desc[[4]])\n            , logistic_true = 1) %>% \n    add_model(boot_train(top_models$form[[5]])\n            , desc = paste('boot_train',top_models$desc[[5]])\n            , logistic_true = 1)\n\n```\n\n```{r boxplot, echo = FALSE}\nboxplots <- bootstrap_results %>% \n  select(desc, train_resamples) %>% \n  unnest(train_resamples) %>% \n  ggplot(aes(desc, ROC, group = desc)) + \n  geom_boxplot() + \n  coord_flip()\n\nprint(boxplots)\nsaveRDS(boxplots, file = \"bootstrap_boxplots_marks.rds\")\n```\n\n\n# 3. Send your designated reviewer the final analysis from creating a regression for the following problem\n\nUsing the `watch_transactions` data frame in this project, create a model that predicts watch band purchases.\n\n```{r watch_data, warning = FALSE}\nwatch_store_trans <- eboxr_read(\"/Users/curtbergmann/Box Sync/Elicit Education/scholar/regclass/watch_store_trans.RDS\",\n           read_fun = readRDS)\n```\n\n```{r explore}\nnames(watch_store_trans)\n```\nThere are 9 variables in the dataset, none with missing values. Each row is a unique **customer_id**, a variable we will not use for analysis.\n\nIt appears appears the dataset represents a snapshot in time for 10,000 customers, where all variables except **watch_band_purchase** *(1 = purchase, 0 = no pruchase)* capture demographic and historical data.\n\n **sales** = historical revenue generated by customer\n **frequency** = historical number of shopping visits by customer\n **watch_sales** = historical revenue generated by customer from watch sales\n **belt_units** = historical belts purchased by customer\n **handbag_units** = historical handbags purchased by customer\n **salary** = customer salary \n **receny_days** = days since last purchase\n\n```{r}\nsummary(watch_band_purchase ~ ., data = watch_store_trans)\n```\n* As expected, **customer_id** doesn't effect likelihood to purchase a watch band. \n* **handbag_units** has a positive relationship until very high levels, which probably indicates people who purchase a TON of handbags aren't interested in watches.\n* **salary** has the expected positive relationship\n* **belt_units** seems to have no effect or even a slighlty negative effect\n* **watch_sales** has the expected positive influence\n* **recency_days** has the expected negative impact (more days since last purchase = less likelyhood to buy watch band)\n* Surprisingly, **frequency** seems to have a slightly negative impact on watch band purchases. Perhaps high frequency buyers tend to purchase other items.\n* Finally, **sales** only has a descerable positive impact on watch band purhcases until the higher revenue levels. This and the frequency data could indicate watch bands are a luxury good.\n\n## Modeling\n\n## Initial model\n```{r}\nformula_all <- as.formula(\"watch_band_purchase ~ handbag_units + salary + belt_units + watch_sales + recency_days + frequency + sales\")\n\nmodel_results <- data_frame() %>% \n    add_model(lrm(formula_all, data=watch_store_trans, y = TRUE),\n            logistic_true = 1,    # what is the value for the predicted dependent variable?\n            desc=\"logistic all variables\")\n\nmodel_results %>%\n  select(desc, auc, AIC, topq, R2)\n\nmodel_results %>%\n  group_by(desc) %>%\n  select(desc, topq_tbl) %>%\n  unnest(topq_tbl) %>% \n  ungroup %>% \n  ggplot(aes(quantile_group_id, cum_conversions, color = desc)) +\n  geom_line()\n```\n\n## Variable correlations\n```{r}\ncorrgram::corrgram(watch_store_trans %>% select(-customer_id), order = TRUE)\n```\n**Frequency** and **sales** are highly correlated. Let's run an anova to see which adds more information.\n```{r, echo = FALSE}\nanova(model_results[[1,'model']], test = \"Chisq\")\n```\n\nSales looks to add more information. But the anova test is direction sensitive so let's try reversing their order.\n```{r, echo = FALSE}\nformula_reverse <- as.formula(\"watch_band_purchase ~ handbag_units + salary + belt_units + watch_sales + recency_days + sales + frequency\")\nformula_reverse2 <- as.formula(\"watch_band_purchase ~  sales + frequency +handbag_units + salary + belt_units + watch_sales + recency_days\")\n\nmodel_results %<>% \n      add_model(lrm(formula_reverse, data=watch_store_trans, y = TRUE)\n                , logistic_true = 1\n                , desc=\"lrm all reverse sales/frequency\") %>% \n        add_model(lrm(formula_reverse2, data=watch_store_trans, y = TRUE)\n                , logistic_true = 1\n                , desc=\"lrm sales/frequency first\")\n\nanova(model_results[[1,'model']], test = \"Chisq\")\nanova(model_results[[2,'model']], test = \"Chisq\")\nanova(model_results[[3,'model']], test = \"Chisq\")\n```\nDoesn't seem to match much. But before removing a variable let's look at non-linearity by adding a spline. \n```{r, echo = FALSE}\nmodel_results %<>%\n  add_model(glm(watch_band_purchase ~ \n                  rcs(handbag_units, 5) +\n                  rcs(salary, 5) + \n                  rcs(belt_units, 5) + \n                  rcs(watch_sales, 5) + \n                  rcs(sales, 5) + \n                  rcs(frequency, 5)\n                , data=watch_store_trans\n                , family = 'binomial')\n            , logistic_true = 1\n            , desc = \"glm all with rcs\")\n\nmodel_results %>% \n  select(desc, auc, topq)\n\n```\n\nThe model now performs worse. But perhaps this is because most of the variables are linear.\n```{r, echo = FALSE}\nsummary(model_results[[6,'model']])\n```\n\nYes, it seems only handbag_units and salary are non-linear. So, let's create a model with rcs() only for those variables..\n```{r}\nmodel_results %<>%\n  add_model(glm(watch_band_purchase ~ \n                  rcs(handbag_units, 5) +\n                  rcs(salary, 5) + \n                  belt_units +\n                  watch_sales + \n                  sales + \n                  frequency\n                , data=watch_store_trans\n                , family = 'binomial')\n            , logistic_true = 1\n            , desc = \"glm all with rcs for handbags and salary\") %>% \n  add_model()\n\nmodel_results %>% \n  select(desc, auc, topq)\n\n```\n\n\n\n\n4. Add `rcs` to all continuous variables\n5. Use `anova` from a `glm` model to see how variable order affects changes in variation\n6. Use `anova` from an `lrm` model to evaluate the non-linear relationship between dependent and independent variables\n7. Add models to a data frame using the `add_model` function\n8. Use AIC, AUC, and TOPQ to evaluate your models\n8. Use cross validation or the bootstrap on your top models to see if one is really better than another\n9. Use `gbm` as a reference model\n10. Use `Function` to extract the equation from your final choice\n12. Use the `top_q_tbls` and a `topq` plot to explain model performance with your client\n",
    "created" : 1512768284066.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1018746714",
    "id" : "D9BCA56E",
    "lastKnownWriteTime" : 1513204043,
    "last_content_update" : 1513204043750,
    "path" : "~/Desktop/R/Elicit Scholar/Regression/regression_marks.rmd",
    "project_path" : "regression_marks.rmd",
    "properties" : {
        "chunk_output_type" : "inline",
        "last_setup_crc32" : "AF280728e347d1b2"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}